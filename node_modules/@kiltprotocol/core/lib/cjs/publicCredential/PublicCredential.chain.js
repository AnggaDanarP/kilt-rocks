"use strict";
/**
 * Copyright (c) 2018-2023, BOTLabs GmbH.
 *
 * This source code is licensed under the BSD 4-Clause "Original" license
 * found in the LICENSE file in the root directory of this source tree.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchCredentialsFromChain = exports.fetchCredentialFromChain = exports.fromChain = exports.toChain = void 0;
const config_1 = require("@kiltprotocol/config");
const did_1 = require("@kiltprotocol/did");
const asset_did_1 = require("@kiltprotocol/asset-did");
const utils_1 = require("@kiltprotocol/utils");
const PublicCredential_js_1 = require("./PublicCredential.js");
const utils_js_1 = require("../utils.js");
/**
 * Format a [[IPublicCredentialInput]] to be used as a parameter for the blockchain API function.

 * @param publicCredential The public credential to format.
 * @returns The blockchain-formatted public credential.
 */
function toChain(publicCredential) {
    const { cTypeHash, claims, subject, delegationId } = publicCredential;
    const cborSerializedClaims = utils_1.cbor.encode(claims);
    return {
        ctypeHash: cTypeHash,
        subject,
        claims: `0x${cborSerializedClaims.toString('hex')}`,
        authorization: delegationId,
    };
}
exports.toChain = toChain;
// Transform a blockchain-formatted public credential [[PublicCredentialsCredentialsCredential]] into the original [[IPublicCredentialInput]].
// It throws if what was written on the chain was garbage.
function credentialInputFromChain({ claims, ctypeHash, authorization, subject, }) {
    const credentialSubject = subject.toUtf8();
    (0, asset_did_1.validateUri)(credentialSubject);
    return {
        claims: utils_1.cbor.decode(claims),
        cTypeHash: ctypeHash.toHex(),
        delegationId: authorization.unwrapOr(undefined)?.toHex() ?? null,
        subject: credentialSubject,
    };
}
/**
 * Decodes the public credential details returned by `api.query.publicCredentials.credentials(subjectId)`.
 *
 * @param encoded The data from the blockchain.
 * @returns The decoded data.
 */
function fromChain(encoded) {
    const { attester, authorizationId, blockNumber, ctypeHash, revoked } = encoded.unwrap();
    return {
        ctypeHash: ctypeHash.toHex(),
        attester: (0, did_1.fromChain)(attester),
        revoked: revoked.toPrimitive(),
        authorizationId: authorizationId.isSome
            ? authorizationId.unwrap().toHex()
            : null,
        blockNumber: blockNumber.toBn(),
    };
}
exports.fromChain = fromChain;
// Given a (nested) call, flattens them and filter by calls that are of type `api.tx.publicCredentials.add`.
function extractPublicCredentialCreationCallsFromDidCall(api, call) {
    const extrinsicCalls = (0, utils_js_1.flattenCalls)(api, call);
    return extrinsicCalls.filter((c) => api.tx.publicCredentials.add.is(c));
}
// Given a (nested) call, flattens them and filter by calls that are of type `api.tx.did.submitDidCall` or `api.tx.did.dispatchAs`.
function extractDidCallsFromBatchCall(api, call) {
    const extrinsicCalls = (0, utils_js_1.flattenCalls)(api, call);
    return extrinsicCalls.filter((c) => api.tx.did.submitDidCall.is(c) || api.tx.did.dispatchAs.is(c));
}
/**
 * Retrieves from the blockchain the [[IPublicCredential]] that is identified by the provided identifier.
 *
 * This is the **only** secure way for users to retrieve and verify a credential.
 *
 * @param credentialId Credential ID to use for the query.
 * @returns The [[IPublicCredential]] as the result of combining the on-chain information and the information present in the tx history.
 */
async function fetchCredentialFromChain(credentialId) {
    const api = config_1.ConfigService.get('api');
    const publicCredentialEntry = await api.call.publicCredentials.getById(credentialId);
    const { blockNumber, revoked } = publicCredentialEntry.unwrap();
    const extrinsic = await (0, utils_js_1.retrieveExtrinsicFromBlock)(api, blockNumber, ({ events }) => events.some((event) => api.events.publicCredentials.CredentialStored.is(event) &&
        event.data[1].toString() === credentialId));
    if (extrinsic === null) {
        throw new utils_1.SDKErrors.PublicCredentialError(`The block number as specified in the provided credential entry (${blockNumber}) does not have any extrinsic that includes a credential creation.`);
    }
    if (!(0, utils_js_1.isBatch)(api, extrinsic) &&
        !api.tx.did.submitDidCall.is(extrinsic) &&
        !api.tx.did.dispatchAs.is(extrinsic)) {
        throw new utils_1.SDKErrors.PublicCredentialError('Extrinsic should be either a `did.submitDidCall` or `did.dispatchAs` extrinsic or a batch containing at least one of those');
    }
    // If we're dealing with a batch, flatten any nested `submit_did_call` calls,
    // otherwise the extrinsic is itself a submit_did_call, so just take it.
    const didCalls = (0, utils_js_1.isBatch)(api, extrinsic)
        ? extrinsic.args[0].flatMap((batchCall) => extractDidCallsFromBatchCall(api, batchCall))
        : [extrinsic];
    // From the list of DID calls, only consider public_credentials::add calls, bundling each of them with their DID submitter.
    // It returns a list of [reconstructedCredential, attesterDid].
    const callCredentialsContent = didCalls.flatMap((didCall) => {
        const publicCredentialCalls = extractPublicCredentialCreationCallsFromDidCall(api, api.tx.did.submitDidCall.is(didCall)
            ? didCall.args[0].call
            : didCall.args[1]);
        // Re-create the issued public credential for each call identified.
        return publicCredentialCalls.map((credentialCreationCall) => [
            credentialInputFromChain(credentialCreationCall.args[0]),
            (0, did_1.fromChain)(api.tx.did.submitDidCall.is(didCall)
                ? didCall.args[0].did
                : didCall.args[0]),
        ]);
    });
    // If more than one call is present, it always considers the last one as the valid one, and takes its attester.
    const lastRightCredentialCreationCall = callCredentialsContent
        .reverse()
        .find(([credential, attester]) => {
        const reconstructedId = (0, PublicCredential_js_1.getIdForCredential)(credential, attester);
        return reconstructedId === credentialId;
    });
    if (!lastRightCredentialCreationCall) {
        throw new utils_1.SDKErrors.PublicCredentialError('Block should always contain the full credential, eventually.');
    }
    const [credentialInput, attester] = lastRightCredentialCreationCall;
    return {
        ...credentialInput,
        attester,
        id: (0, PublicCredential_js_1.getIdForCredential)(credentialInput, attester),
        blockNumber,
        revoked: revoked.toPrimitive(),
    };
}
exports.fetchCredentialFromChain = fetchCredentialFromChain;
/**
 * Retrieves from the blockchain the [[IPublicCredential]]s that have been issued to the provided AssetDID.
 *
 * This is the **only** secure way for users to retrieve and verify all the credentials issued to a given [[AssetDidUri]].
 *
 * @param subject The AssetDID of the subject.
 * @returns An array of [[IPublicCredential]] as the result of combining the on-chain information and the information present in the tx history.
 */
async function fetchCredentialsFromChain(subject) {
    const api = config_1.ConfigService.get('api');
    const publicCredentialEntries = await api.call.publicCredentials.getBySubject(subject, null);
    if (publicCredentialEntries.isErr) {
        throw new Error(publicCredentialEntries.asErr.toString());
    }
    return Promise.all(publicCredentialEntries.asOk.map(([encodedId]) => fetchCredentialFromChain(encodedId.toHex())));
}
exports.fetchCredentialsFromChain = fetchCredentialsFromChain;
