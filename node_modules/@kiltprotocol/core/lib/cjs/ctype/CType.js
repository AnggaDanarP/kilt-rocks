"use strict";
/**
 * Copyright (c) 2018-2023, BOTLabs GmbH.
 *
 * This source code is licensed under the BSD 4-Clause "Original" license
 * found in the LICENSE file in the root directory of this source tree.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.isICType = exports.fromProperties = exports.verifyCTypeMetadata = exports.verifyClaimAgainstNestedSchemas = exports.verifyDataStructure = exports.verifyStored = exports.verifyClaimAgainstSchema = exports.verifyObjectAgainstSchema = exports.getIdForSchema = exports.idToHash = exports.hashToId = exports.getHashForSchema = exports.serializeForHash = void 0;
const utils_1 = require("@kiltprotocol/utils");
const config_1 = require("@kiltprotocol/config");
const CType_schemas_js_1 = require("./CType.schemas.js");
let notifyDeprecated = () => {
    // do nothing
};
if (typeof process !== 'undefined' &&
    process.env?.NODE_ENV &&
    process.env.NODE_ENV !== 'production') {
    const logger = config_1.ConfigService.LoggingFactory.getLogger('deprecated');
    const alreadyNotified = new Set();
    notifyDeprecated = (cTypeId) => {
        if (alreadyNotified.has(cTypeId)) {
            return;
        }
        logger.warn(`Your application has processed the CType '${cTypeId}' which follows the meta schema '${CType_schemas_js_1.CTypeModelDraft01.$id}'. This class of schemas has known issues that can result in unexpected properties being present in a credential. Consider switching to a CType based on meta schema ${CType_schemas_js_1.CTypeModelV1.$id} which fixes this issue.`);
        alreadyNotified.add(cTypeId);
    };
}
/**
 * Utility for (re)creating CType hashes. Sorts the schema and strips the $id property (which contains the CType hash) before stringifying.
 *
 * @param cType The CType (with or without $id).
 * @returns A deterministic JSON serialization of a CType, omitting the $id property.
 */
function serializeForHash(cType) {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const { $id, ...schemaWithoutId } = cType;
    return utils_1.Crypto.encodeObjectAsStr(schemaWithoutId);
}
exports.serializeForHash = serializeForHash;
/**
 * Calculates the CType hash from a schema.
 *
 * @param cType The ICType (with or without $id).
 * @returns Hash as hex string.
 */
function getHashForSchema(cType) {
    const serializedSchema = serializeForHash(cType);
    return utils_1.Crypto.hashStr(serializedSchema);
}
exports.getHashForSchema = getHashForSchema;
/**
 * Calculates the schema $id from a CType hash.
 *
 * @param hash CType hash as hex string.
 * @returns Schema id uri.
 */
function hashToId(hash) {
    return `kilt:ctype:${hash}`;
}
exports.hashToId = hashToId;
/**
 * Extracts the CType hash from a CType $id.
 *
 * @param id A CType id of the form 'kilt:ctype:0x[0-9a-f]'.
 * @returns The CType hash as a zero-prefixed string of hex digits.
 */
function idToHash(id) {
    const result = id.match(/kilt:ctype:(0x[0-9a-f]+)/i);
    if (!result)
        throw new utils_1.SDKErrors.CTypeHashMissingError(`The string ${id} is not a valid CType id`);
    return result[1];
}
exports.idToHash = idToHash;
/**
 * Calculates the schema $id for a CType schema by hashing it.
 *
 * @param schema CType schema for which to create schema id.
 * @returns Schema id uri.
 */
function getIdForSchema(schema) {
    return hashToId(getHashForSchema(schema));
}
exports.getIdForSchema = getIdForSchema;
/**
 * Verifies data against CType schema or CType schema against meta-schema.
 *
 * @param object Data to be verified against schema.
 * @param schema Schema to verify against.
 * @param messages Optional empty array. If passed, this receives all verification errors.
 * @param referencedSchemas If schema contains references ($ref) to other schemas, their definitions must be added here in form of an array.
 */
function verifyObjectAgainstSchema(object, schema, messages, referencedSchemas) {
    const validator = new utils_1.JsonSchema.Validator(schema, '7', false);
    if (referencedSchemas) {
        referencedSchemas.forEach((i) => validator.addSchema(i));
    }
    const { valid, errors } = validator.validate(object);
    if (valid === true)
        return;
    if (messages) {
        errors.forEach((error) => {
            messages.push(error.error);
        });
    }
    throw new utils_1.SDKErrors.ObjectUnverifiableError('JSON schema verification failed for object', { cause: errors });
}
exports.verifyObjectAgainstSchema = verifyObjectAgainstSchema;
/**
 * Verifies the structure of the provided IClaim['contents'] with [[ICType]].
 *
 * @param claimContents IClaim['contents'] to be verified against the schema.
 * @param schema ICType to be verified against the [[CTypeModel]].
 * @param messages An array, which will be filled by schema errors.
 */
function verifyClaimAgainstSchema(claimContents, schema, messages) {
    verifyObjectAgainstSchema(schema, CType_schemas_js_1.CTypeModel, messages);
    if (schema.$schema === CType_schemas_js_1.CTypeModelDraft01.$id) {
        notifyDeprecated(schema.$id);
    }
    verifyObjectAgainstSchema(claimContents, schema, messages);
}
exports.verifyClaimAgainstSchema = verifyClaimAgainstSchema;
/**
 * Checks on the KILT blockchain whether a CType is registered.
 *
 * @param cType CType data.
 */
async function verifyStored(cType) {
    const api = config_1.ConfigService.get('api');
    const hash = idToHash(cType.$id);
    const encoded = await api.query.ctype.ctypes(hash);
    if (encoded.isNone)
        throw new utils_1.SDKErrors.CTypeHashMissingError(`CType with hash ${hash} is not registered on chain`);
}
exports.verifyStored = verifyStored;
/**
 * Checks whether the input meets all the required criteria of an ICType object.
 * Throws on invalid input.
 *
 * @param input The ICType object.
 */
function verifyDataStructure(input) {
    verifyObjectAgainstSchema(input, CType_schemas_js_1.CTypeModel);
    if (input.$schema === CType_schemas_js_1.CTypeModelDraft01.$id) {
        notifyDeprecated(input.$id);
    }
    const idFromSchema = getIdForSchema(input);
    if (idFromSchema !== input.$id) {
        throw new utils_1.SDKErrors.CTypeIdMismatchError(idFromSchema, input.$id);
    }
}
exports.verifyDataStructure = verifyDataStructure;
/**
 * Validates an array of [[CType]]s against a [[Claim]].
 *
 * @param cType - A [[CType]] that has nested [[CType]]s inside.
 * @param nestedCTypes - An array of [[CType]] schemas.
 * @param claimContents - The contents of a [[Claim]] to be validated.
 * @param messages - Optional empty array. If passed, this receives all verification errors.
 */
function verifyClaimAgainstNestedSchemas(cType, nestedCTypes, claimContents, messages) {
    verifyObjectAgainstSchema(cType, CType_schemas_js_1.CTypeModel, messages);
    verifyObjectAgainstSchema(claimContents, cType, messages, nestedCTypes);
}
exports.verifyClaimAgainstNestedSchemas = verifyClaimAgainstNestedSchemas;
/**
 * Checks a CTypeMetadata object.
 *
 * @param metadata [[ICTypeMetadata]] that is to be instantiated.
 */
function verifyCTypeMetadata(metadata) {
    verifyObjectAgainstSchema(metadata, CType_schemas_js_1.MetadataModel);
}
exports.verifyCTypeMetadata = verifyCTypeMetadata;
const cTypeVersionToSchemaId = {
    'draft-01': CType_schemas_js_1.CTypeModelDraft01.$id,
    V1: CType_schemas_js_1.CTypeModelV1.$id,
};
/**
 * Creates a new [[ICType]] object from a set of atomic claims and a title.
 * The CType id will be automatically generated.
 *
 * @param title The new CType's title as a string.
 * @param properties Key-value pairs describing the admissible atomic claims for a credential with this CType. The value of each property is a json-schema (for example `{ "type": "number" }`) used to validate that property.
 * @param version Use 'V1' to create a CType according to the latest metaschema version (default) and 'draft-01' to produce a legacy CType. Included for backwards-compatibility.
 * @returns A complete JSON schema (CType) with an $id derived from the hashed schema. Each CType references a meta schema that applies to it via the $schema property; its value depends on the `version` parameter.
 */
function fromProperties(title, properties, version = 'V1') {
    const schema = {
        properties,
        title,
        $schema: cTypeVersionToSchemaId[version],
        type: 'object',
    };
    if (version === 'V1') {
        schema.additionalProperties = false;
    }
    const cType = utils_1.jsonabc.sortObj({ ...schema, $id: getIdForSchema(schema) });
    verifyDataStructure(cType);
    return cType;
}
exports.fromProperties = fromProperties;
/**
 * Custom Type Guard to determine input being of type ICType.
 *
 * @param input The potentially only partial ICType.
 *
 * @returns Boolean whether input is of type ICType.
 */
function isICType(input) {
    try {
        verifyDataStructure(input);
    }
    catch (error) {
        return false;
    }
    return true;
}
exports.isICType = isICType;
