"use strict";
/**
 * Copyright (c) 2018-2023, BOTLabs GmbH.
 *
 * This source code is licensed under the BSD 4-Clause "Original" license
 * found in the LICENSE file in the root directory of this source tree.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchFromChain = exports.fromChain = exports.idToChain = exports.toChain = void 0;
const tslib_1 = require("tslib");
const config_1 = require("@kiltprotocol/config");
const Did = tslib_1.__importStar(require("@kiltprotocol/did"));
const utils_1 = require("@kiltprotocol/utils");
const CType_js_1 = require("./CType.js");
const utils_js_1 = require("../utils.js");
/**
 * Encodes the provided CType for use in `api.tx.ctype.add()`.
 *
 * @param cType The CType to write on the blockchain.
 * @returns Encoded CType.
 */
function toChain(cType) {
    return (0, CType_js_1.serializeForHash)(cType);
}
exports.toChain = toChain;
/**
 * Encodes the provided CType['$id'] for use in `api.query.ctype.ctypes()`.
 *
 * @param cTypeId The CType id to translate for the blockchain.
 * @returns Encoded CType id.
 */
function idToChain(cTypeId) {
    return (0, CType_js_1.idToHash)(cTypeId);
}
exports.idToChain = idToChain;
// Transform a blockchain-formatted CType input (represented as Bytes) into the original [[ICType]].
// It throws if what was written on the chain was garbage.
function cTypeInputFromChain(input) {
    try {
        // Throws on invalid JSON input. CType is expected to be a valid JSON document.
        const reconstructedObject = JSON.parse(input.toUtf8());
        // Re-compute the ID to validate the resulting ICType.
        const reconstructedCTypeId = (0, CType_js_1.hashToId)((0, CType_js_1.getHashForSchema)(reconstructedObject));
        const reconstructedCType = {
            ...reconstructedObject,
            $id: reconstructedCTypeId,
        };
        // If throws if the input was a valid JSON but not a valid CType.
        (0, CType_js_1.verifyDataStructure)(reconstructedCType);
        return reconstructedCType;
    }
    catch (cause) {
        throw new utils_1.SDKErrors.CTypeError(`The provided payload cannot be parsed as a CType: ${input.toHuman()}`, { cause });
    }
}
// eslint-disable-next-line jsdoc/require-jsdoc
function fromChain(encoded) {
    const unwrapped = encoded.unwrap();
    if ('creator' in unwrapped && 'createdAt' in unwrapped) {
        const { creator, createdAt } = unwrapped;
        return {
            creator: Did.fromChain(creator),
            createdAt: createdAt.toBn(),
        };
    }
    return {
        creator: Did.fromChain(unwrapped),
    };
}
exports.fromChain = fromChain;
// Given a (nested) call, flattens them and filter by calls that are of type `api.tx.ctype.add`.
function extractCTypeCreationCallsFromDidCall(api, call) {
    const extrinsicCalls = (0, utils_js_1.flattenCalls)(api, call);
    return extrinsicCalls.filter((c) => api.tx.ctype.add.is(c));
}
// Given a (nested) call, flattens them and filter by calls that are of type `api.tx.did.submitDidCall` or `api.tx.did.dispatchAs`.
function extractDidCallsFromBatchCall(api, call) {
    const extrinsicCalls = (0, utils_js_1.flattenCalls)(api, call);
    return extrinsicCalls.filter((c) => api.tx.did.submitDidCall.is(c) || api.tx.did.dispatchAs.is(c));
}
/**
 * Resolves a CType identifier to the CType definition by fetching data from the block containing the transaction that registered the CType on chain.
 *
 * @param cTypeId CType ID to use for the query. It is required to complement the information stored on the blockchain in a [[CtypeCtypeEntry]].
 *
 * @returns The [[ICTypeDetails]] as the result of combining the on-chain information and the information present in the tx history.
 */
async function fetchFromChain(cTypeId) {
    const api = config_1.ConfigService.get('api');
    const cTypeHash = (0, CType_js_1.idToHash)(cTypeId);
    const cTypeEntry = await api.query.ctype.ctypes(cTypeHash);
    const { createdAt } = fromChain(cTypeEntry);
    if (typeof createdAt === 'undefined')
        throw new utils_1.SDKErrors.CTypeError('Cannot fetch CType definitions on a chain that does not store the createdAt block');
    const extrinsic = await (0, utils_js_1.retrieveExtrinsicFromBlock)(api, createdAt, ({ events }) => events.some((event) => api.events.ctype.CTypeCreated.is(event) &&
        event.data[1].toString() === cTypeHash));
    if (extrinsic === null) {
        throw new utils_1.SDKErrors.CTypeError(`There is not CType with the provided ID "${cTypeId}" on chain.`);
    }
    if (!(0, utils_js_1.isBatch)(api, extrinsic) &&
        !api.tx.did.submitDidCall.is(extrinsic) &&
        !api.tx.did.dispatchAs.is(extrinsic)) {
        throw new utils_1.SDKErrors.PublicCredentialError('Extrinsic should be either a `did.submitDidCall` or `did.dispatchAs` extrinsic or a batch containing at least one of those');
    }
    // If we're dealing with a batch, flatten any nested `submit_did_call` calls,
    // otherwise the extrinsic is itself a submit_did_call, so just take it.
    const didCalls = (0, utils_js_1.isBatch)(api, extrinsic)
        ? extrinsic.args[0].flatMap((batchCall) => extractDidCallsFromBatchCall(api, batchCall))
        : [extrinsic];
    // From the list of DID calls, only consider ctype::add calls, bundling each of them with their DID submitter.
    // It returns a list of [reconstructedCType, attesterDid].
    const ctypeCallContent = didCalls.flatMap((didCall) => {
        const ctypeCreationCalls = extractCTypeCreationCallsFromDidCall(api, api.tx.did.submitDidCall.is(didCall)
            ? didCall.args[0].call
            : didCall.args[1]);
        // Re-create the issued public credential for each call identified.
        return ctypeCreationCalls.map((ctypeCreationCall) => [
            cTypeInputFromChain(ctypeCreationCall.args[0]),
            Did.fromChain(api.tx.did.submitDidCall.is(didCall)
                ? didCall.args[0].did
                : didCall.args[0]),
        ]);
    });
    // If more than a call is present, it always considers the last one as the valid one.
    const lastRightCTypeCreationCall = ctypeCallContent
        .reverse()
        .find((cTypeInput) => {
        return cTypeInput[0].$id === cTypeId;
    });
    if (!lastRightCTypeCreationCall) {
        throw new utils_1.SDKErrors.CTypeError('Block should always contain the full CType, eventually.');
    }
    const [ctypeInput, creator] = lastRightCTypeCreationCall;
    return {
        cType: {
            ...ctypeInput,
            $id: cTypeId,
        },
        creator,
        createdAt,
    };
}
exports.fetchFromChain = fetchFromChain;
