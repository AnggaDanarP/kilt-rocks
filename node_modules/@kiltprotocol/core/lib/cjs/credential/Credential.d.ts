/**
 * Copyright (c) 2018-2023, BOTLabs GmbH.
 *
 * This source code is licensed under the BSD 4-Clause "Original" license
 * found in the LICENSE file in the root directory of this source tree.
 */
import type { DidResolveKey, DidUri, Hash, IAttestation, IClaim, ICredential, ICredentialPresentation, ICType, IDelegationNode, SignCallback } from '@kiltprotocol/types';
/**
 * Calculates the root hash of the credential.
 *
 * @param credential The credential object.
 * @returns The hash.
 */
export declare function calculateRootHash(credential: Partial<ICredential>): Hash;
/**
 * Removes [[Claim]] properties from the [[Credential]] object, provides anonymity and security when building the [[createPresentation]] method.
 *
 * @param credential - The Credential object to remove properties from.
 * @param properties - Properties to remove from the [[Claim]] object.
 * @returns A cloned Credential with removed properties.
 */
export declare function removeClaimProperties(credential: ICredential, properties: string[]): ICredential;
/**
 * Prepares credential data for signing.
 *
 * @param input - The Credential to prepare the data for.
 * @param challenge - An optional challenge to be included in the signing process.
 * @returns The prepared signing data as Uint8Array.
 */
export declare function makeSigningData(input: ICredential, challenge?: string): Uint8Array;
/**
 * Verifies if the credential hash matches the contents of it.
 *
 * @param input - The credential to check.
 */
export declare function verifyRootHash(input: ICredential): void;
/**
 * Verifies the data of the [[Credential]] object; used to check that the data was not tampered with,
 * by checking the data against hashes. Throws if invalid.
 *
 * @param input - The [[Credential]] for which to verify data.
 */
export declare function verifyDataIntegrity(input: ICredential): void;
/**
 * Checks whether the input meets all the required criteria of an [[ICredential]] object.
 * Throws on invalid input.
 *
 * @param input - A potentially only partial [[Credential]].
 *
 */
export declare function verifyDataStructure(input: ICredential): void;
/**
 * Verifies the signature of the [[ICredentialPresentation]].
 * It supports migrated DIDs, meaning that if the original claim within the [[ICredential]] included a light DID that was afterwards upgraded,
 * the signature over the presentation **must** be generated with the full DID in order for the verification to be successful.
 * On the other hand, a light DID that has been migrated and then deleted from the chain will not be allowed to generate valid presentations anymore.
 *
 * @param input - The [[ICredentialPresentation]].
 * @param verificationOpts Additional verification options.
 * @param verificationOpts.didResolveKey - The function used to resolve the claimer's key. Defaults to [[resolveKey]].
 * @param verificationOpts.challenge - The expected value of the challenge. Verification will fail in case of a mismatch.
 */
export declare function verifySignature(input: ICredentialPresentation, { challenge, didResolveKey, }?: {
    challenge?: string;
    didResolveKey?: DidResolveKey;
}): Promise<void>;
export declare type Options = {
    legitimations?: ICredential[];
    delegationId?: IDelegationNode['id'] | null;
};
/**
 * Builds a new [[ICredential]] object, from a complete set of required parameters.
 *
 * @param claim An [[IClaim]] object to build the credential for.
 * @param option Container for different options that can be passed to this method.
 * @param option.legitimations Array of [[Credential]] objects of the Attester which the Claimer requests to include into the attestation as legitimations.
 * @param option.delegationId The id of the DelegationNode of the Attester, which should be used in the attestation.
 * @returns A new [[ICredential]] object.
 */
export declare function fromClaim(claim: IClaim, { legitimations, delegationId }?: Options): ICredential;
declare type VerifyOptions = {
    ctype?: ICType;
    challenge?: string;
    didResolveKey?: DidResolveKey;
};
/**
 * Verifies data structure & data integrity of a credential object.
 * This combines all offline sanity checks that can be performed on an ICredential object.
 * A credential is valid only if it is well formed AND there is an on-chain attestation record referencing its root hash.
 * To check the latter condition as well, you need to call [[verifyCredential]] or [[verifyPresentation]].
 *
 * @param credential - The object to check.
 * @param options - Additional parameter for more verification steps.
 * @param options.ctype - CType which the included claim should be checked against.
 */
export declare function verifyWellFormed(credential: ICredential, { ctype }?: VerifyOptions): void;
/**
 * Queries the attestation record for a credential and matches their data. Fails if no attestation exists, if it is revoked, or if the attestation data does not match the credential.
 *
 * @param credential The [[ICredential]] whose attestation status should be checked.
 * @returns An object containing the `attester` DID and `revoked` status of the on-chain attestation.
 */
export declare function verifyAttested(credential: ICredential): Promise<{
    attester: DidUri;
    revoked: boolean;
}>;
export interface VerifiedCredential extends ICredential {
    revoked: boolean;
    attester: DidUri;
}
/**
 * Updates the revocation status of a previously verified credential to allow checking if it is still valid.
 *
 * @param verifiedCredential The output of [[verifyCredential]] or [[verifyPresentation]], which adds a `revoked` and `attester` property.
 * @returns A promise of resolving to the same object but with the `revoked` property updated.
 * The promise rejects if the attestation has been deleted or its data changed since verification.
 */
export declare function refreshRevocationStatus(verifiedCredential: VerifiedCredential): Promise<VerifiedCredential>;
/**
 * Performs all steps to verify a credential (unsigned), which includes verifying data structure, data integrity, and looking up its attestation on the KILT blockchain.
 * In most cases, credentials submitted by a third party would be expected to be signed (a 'presentation').
 * To verify the additional signature as well, use `verifyPresentation`.
 *
 * @param credential - The object to check.
 * @param options - Additional parameter for more verification steps.
 * @param options.ctype - CType which the included claim should be checked against.
 * @returns A [[VerifiedCredential]] object, which is the orignal credential with two additional properties: a boolean `revoked` status flag and the `attester` DID.
 */
export declare function verifyCredential(credential: ICredential, { ctype }?: VerifyOptions): Promise<VerifiedCredential>;
/**
 * Performs all steps to verify a credential presentation (signed).
 * In addition to verifying data structure, data integrity, and looking up the attestation record on the KILT blockchain,
 * this involves verifying the claimer's signature over the credential.
 *
 * This is the function verifiers would typically call upon receiving a credential presentation from a third party.
 * The attester's identity and the credential revocation status returned by this function would then be either displayed to an end user
 * or processed in application logic deciding whether to accept or reject a credential submission
 * (e.g., by matching the attester DID against an allow-list of trusted attesters).
 *
 * @param presentation - The object to check.
 * @param options - Additional parameter for more verification steps.
 * @param options.ctype - CType which the included claim should be checked against.
 * @param options.challenge -  The expected value of the challenge. Verification will fail in case of a mismatch.
 * @param options.didResolveKey - The function used to resolve the claimer's key. Defaults to [[resolveKey]].
 * @returns A [[VerifiedCredential]] object, which is the orignal credential presentation with two additional properties:
 * a boolean `revoked` status flag and the `attester` DID.
 */
export declare function verifyPresentation(presentation: ICredentialPresentation, { ctype, challenge, didResolveKey }?: VerifyOptions): Promise<VerifiedCredential>;
/**
 * Type Guard to determine input being of type [[ICredential]].
 *
 * @param input - A potentially only partial [[ICredential]].
 *
 * @returns  Boolean whether input is of type ICredential.
 */
export declare function isICredential(input: unknown): input is ICredential;
/**
 * Type Guard to determine input being of type [[ICredentialPresentation]].
 *
 * @param input - An [[ICredential]], [[ICredentialPresentation]], or other object.
 *
 * @returns  Boolean whether input is of type ICredentialPresentation.
 */
export declare function isPresentation(input: unknown): input is ICredentialPresentation;
/**
 * Gets the hash of the credential.
 *
 * @param credential - The credential to get the hash from.
 * @returns The hash of the credential.
 */
export declare function getHash(credential: ICredential): IAttestation['claimHash'];
/**
 * Creates a public presentation which can be sent to a verifier.
 * This presentation is signed.
 *
 * @param presentationOptions The additional options to use upon presentation generation.
 * @param presentationOptions.credential The credential to create the presentation for.
 * @param presentationOptions.signCallback The callback to sign the presentation.
 * @param presentationOptions.selectedAttributes All properties of the claim which have been requested by the verifier and therefore must be publicly presented.
 * @param presentationOptions.challenge Challenge which will be part of the presentation signature.
 * If not specified, all attributes are shown. If set to an empty array, we hide all attributes inside the claim for the presentation.
 * @returns A deep copy of the Credential with all but `publicAttributes` removed.
 */
export declare function createPresentation({ credential, signCallback, selectedAttributes, challenge, }: {
    credential: ICredential;
    signCallback: SignCallback;
    selectedAttributes?: string[];
    challenge?: string;
}): Promise<ICredentialPresentation>;
export {};
