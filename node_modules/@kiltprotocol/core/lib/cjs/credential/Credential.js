"use strict";
/**
 * Copyright (c) 2018-2023, BOTLabs GmbH.
 *
 * This source code is licensed under the BSD 4-Clause "Original" license
 * found in the LICENSE file in the root directory of this source tree.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPresentation = exports.getHash = exports.isPresentation = exports.isICredential = exports.verifyPresentation = exports.verifyCredential = exports.refreshRevocationStatus = exports.verifyAttested = exports.verifyWellFormed = exports.fromClaim = exports.verifySignature = exports.verifyDataStructure = exports.verifyDataIntegrity = exports.verifyRootHash = exports.makeSigningData = exports.removeClaimProperties = exports.calculateRootHash = void 0;
const tslib_1 = require("tslib");
/**
 * Credentials are a core building block of the KILT SDK.
 * A Credential represents a [[Claim]] which needs to be validated. In practice, the Credential is sent from a claimer to an attester for attesting and to a verifier for verification.
 *
 * A Credential object contains the [[Claim]] and its hash, and legitimations/delegationId of the attester.
 * The credential is made tamper-proof by hashing the claim properties and generating a digest from that, which is used to reference the Credential.
 * It can be signed by the claimer, to authenticate the holder and to prevent replay attacks.
 * A Credential also supports hiding of claim data during a credential presentation.
 *
 * @packageDocumentation
 */
const config_1 = require("@kiltprotocol/config");
const did_1 = require("@kiltprotocol/did");
const utils_1 = require("@kiltprotocol/utils");
const Attestation = tslib_1.__importStar(require("../attestation/index.js"));
const Claim = tslib_1.__importStar(require("../claim/index.js"));
const index_js_1 = require("../claim/index.js");
const index_js_2 = require("../ctype/index.js");
function getHashRoot(leaves) {
    const result = utils_1.Crypto.u8aConcat(...leaves);
    return utils_1.Crypto.hash(result);
}
function getHashLeaves(claimHashes, legitimations, delegationId) {
    const result = claimHashes.map((item) => utils_1.Crypto.coToUInt8(item));
    if (legitimations) {
        legitimations.forEach((legitimation) => {
            result.push(utils_1.Crypto.coToUInt8(legitimation.rootHash));
        });
    }
    if (delegationId) {
        result.push(utils_1.Crypto.coToUInt8(delegationId));
    }
    return result;
}
/**
 * Calculates the root hash of the credential.
 *
 * @param credential The credential object.
 * @returns The hash.
 */
function calculateRootHash(credential) {
    const hashes = getHashLeaves(credential.claimHashes || [], credential.legitimations || [], credential.delegationId || null);
    const root = getHashRoot(hashes);
    return utils_1.Crypto.u8aToHex(root);
}
exports.calculateRootHash = calculateRootHash;
/**
 * Removes [[Claim]] properties from the [[Credential]] object, provides anonymity and security when building the [[createPresentation]] method.
 *
 * @param credential - The Credential object to remove properties from.
 * @param properties - Properties to remove from the [[Claim]] object.
 * @returns A cloned Credential with removed properties.
 */
function removeClaimProperties(credential, properties) {
    const presentation = 
    // clone the credential because properties will be deleted later.
    // TODO: find a nice way to clone stuff
    JSON.parse(JSON.stringify(credential));
    properties.forEach((key) => {
        delete presentation.claim.contents[key];
    });
    presentation.claimNonceMap = (0, index_js_1.hashClaimContents)(presentation.claim, {
        nonces: presentation.claimNonceMap,
    }).nonceMap;
    return presentation;
}
exports.removeClaimProperties = removeClaimProperties;
/**
 * Prepares credential data for signing.
 *
 * @param input - The Credential to prepare the data for.
 * @param challenge - An optional challenge to be included in the signing process.
 * @returns The prepared signing data as Uint8Array.
 */
function makeSigningData(input, challenge) {
    return new Uint8Array([
        ...utils_1.Crypto.coToUInt8(input.rootHash),
        ...utils_1.Crypto.coToUInt8(challenge),
    ]);
}
exports.makeSigningData = makeSigningData;
/**
 * Verifies if the credential hash matches the contents of it.
 *
 * @param input - The credential to check.
 */
function verifyRootHash(input) {
    if (input.rootHash !== calculateRootHash(input)) {
        throw new utils_1.SDKErrors.RootHashUnverifiableError();
    }
}
exports.verifyRootHash = verifyRootHash;
/**
 * Verifies the data of the [[Credential]] object; used to check that the data was not tampered with,
 * by checking the data against hashes. Throws if invalid.
 *
 * @param input - The [[Credential]] for which to verify data.
 */
function verifyDataIntegrity(input) {
    // check claim hash
    verifyRootHash(input);
    // verify properties against selective disclosure proof
    Claim.verifyDisclosedAttributes(input.claim, {
        nonces: input.claimNonceMap,
        hashes: input.claimHashes,
    });
    // check legitimations
    input.legitimations.forEach(verifyDataIntegrity);
}
exports.verifyDataIntegrity = verifyDataIntegrity;
/**
 * Checks whether the input meets all the required criteria of an [[ICredential]] object.
 * Throws on invalid input.
 *
 * @param input - A potentially only partial [[Credential]].
 *
 */
function verifyDataStructure(input) {
    if (!('claim' in input)) {
        throw new utils_1.SDKErrors.ClaimMissingError();
    }
    else {
        Claim.verifyDataStructure(input.claim);
    }
    if (!input.claim.owner) {
        throw new utils_1.SDKErrors.OwnerMissingError();
    }
    if (!Array.isArray(input.legitimations)) {
        throw new utils_1.SDKErrors.LegitimationsMissingError();
    }
    if (!('claimNonceMap' in input)) {
        throw new utils_1.SDKErrors.ClaimNonceMapMissingError();
    }
    if (typeof input.claimNonceMap !== 'object') {
        throw new utils_1.SDKErrors.ClaimNonceMapMalformedError();
    }
    Object.entries(input.claimNonceMap).forEach(([digest, nonce]) => {
        utils_1.DataUtils.verifyIsHex(digest, 256);
        if (!digest || typeof nonce !== 'string' || !nonce) {
            throw new utils_1.SDKErrors.ClaimNonceMapMalformedError();
        }
    });
    if (!('claimHashes' in input)) {
        throw new utils_1.SDKErrors.DataStructureError('claim hashes not provided');
    }
    if (typeof input.delegationId !== 'string' && input.delegationId !== null) {
        throw new utils_1.SDKErrors.DelegationIdTypeError();
    }
}
exports.verifyDataStructure = verifyDataStructure;
/**
 * Verifies the signature of the [[ICredentialPresentation]].
 * It supports migrated DIDs, meaning that if the original claim within the [[ICredential]] included a light DID that was afterwards upgraded,
 * the signature over the presentation **must** be generated with the full DID in order for the verification to be successful.
 * On the other hand, a light DID that has been migrated and then deleted from the chain will not be allowed to generate valid presentations anymore.
 *
 * @param input - The [[ICredentialPresentation]].
 * @param verificationOpts Additional verification options.
 * @param verificationOpts.didResolveKey - The function used to resolve the claimer's key. Defaults to [[resolveKey]].
 * @param verificationOpts.challenge - The expected value of the challenge. Verification will fail in case of a mismatch.
 */
async function verifySignature(input, { challenge, didResolveKey = did_1.resolveKey, } = {}) {
    const { claimerSignature } = input;
    if (challenge && challenge !== claimerSignature.challenge) {
        throw new utils_1.SDKErrors.SignatureUnverifiableError('Challenge differs from expected');
    }
    const signingData = makeSigningData(input, claimerSignature.challenge);
    await (0, did_1.verifyDidSignature)({
        ...(0, did_1.signatureFromJson)(claimerSignature),
        message: signingData,
        // check if credential owner matches signer
        expectedSigner: input.claim.owner,
        // allow full did to sign presentation if owned by corresponding light did
        allowUpgraded: true,
        expectedVerificationMethod: 'authentication',
        didResolveKey,
    });
}
exports.verifySignature = verifySignature;
/**
 * Builds a new [[ICredential]] object, from a complete set of required parameters.
 *
 * @param claim An [[IClaim]] object to build the credential for.
 * @param option Container for different options that can be passed to this method.
 * @param option.legitimations Array of [[Credential]] objects of the Attester which the Claimer requests to include into the attestation as legitimations.
 * @param option.delegationId The id of the DelegationNode of the Attester, which should be used in the attestation.
 * @returns A new [[ICredential]] object.
 */
function fromClaim(claim, { legitimations = [], delegationId = null } = {}) {
    const { hashes: claimHashes, nonceMap: claimNonceMap } = Claim.hashClaimContents(claim);
    const rootHash = calculateRootHash({
        legitimations,
        claimHashes,
        delegationId,
    });
    const credential = {
        claim,
        legitimations,
        claimHashes,
        claimNonceMap,
        rootHash,
        delegationId,
    };
    verifyDataStructure(credential);
    return credential;
}
exports.fromClaim = fromClaim;
/**
 * Verifies data structure & data integrity of a credential object.
 * This combines all offline sanity checks that can be performed on an ICredential object.
 * A credential is valid only if it is well formed AND there is an on-chain attestation record referencing its root hash.
 * To check the latter condition as well, you need to call [[verifyCredential]] or [[verifyPresentation]].
 *
 * @param credential - The object to check.
 * @param options - Additional parameter for more verification steps.
 * @param options.ctype - CType which the included claim should be checked against.
 */
function verifyWellFormed(credential, { ctype } = {}) {
    verifyDataStructure(credential);
    verifyDataIntegrity(credential);
    if (ctype) {
        if (`kilt:ctype:${credential.claim.cTypeHash}` !== ctype.$id) {
            throw new utils_1.SDKErrors.CTypeIdMismatchError(ctype.$id, credential.claim.cTypeHash);
        }
        (0, index_js_2.verifyClaimAgainstSchema)(credential.claim.contents, ctype);
    }
}
exports.verifyWellFormed = verifyWellFormed;
/**
 * Queries the attestation record for a credential and matches their data. Fails if no attestation exists, if it is revoked, or if the attestation data does not match the credential.
 *
 * @param credential The [[ICredential]] whose attestation status should be checked.
 * @returns An object containing the `attester` DID and `revoked` status of the on-chain attestation.
 */
async function verifyAttested(credential) {
    const api = config_1.ConfigService.get('api');
    const { rootHash } = credential;
    const maybeAttestation = await api.query.attestation.attestations(rootHash);
    if (maybeAttestation.isNone) {
        throw new utils_1.SDKErrors.CredentialUnverifiableError('Attestation not found');
    }
    const attestation = Attestation.fromChain(maybeAttestation, credential.rootHash);
    Attestation.verifyAgainstCredential(attestation, credential);
    const { owner: attester, revoked } = attestation;
    return { attester, revoked };
}
exports.verifyAttested = verifyAttested;
/**
 * Updates the revocation status of a previously verified credential to allow checking if it is still valid.
 *
 * @param verifiedCredential The output of [[verifyCredential]] or [[verifyPresentation]], which adds a `revoked` and `attester` property.
 * @returns A promise of resolving to the same object but with the `revoked` property updated.
 * The promise rejects if the attestation has been deleted or its data changed since verification.
 */
async function refreshRevocationStatus(verifiedCredential) {
    if (typeof verifiedCredential.attester !== 'string' ||
        typeof verifiedCredential.revoked !== 'boolean') {
        throw new TypeError('This function expects a VerifiedCredential with properties `revoked` (boolean) and `attester` (string)');
    }
    const { revoked, attester } = await verifyAttested(verifiedCredential);
    if (attester !== verifiedCredential.attester) {
        throw new utils_1.SDKErrors.CredentialUnverifiableError('Attester has changed since first verification');
    }
    return { ...verifiedCredential, revoked };
}
exports.refreshRevocationStatus = refreshRevocationStatus;
/**
 * Performs all steps to verify a credential (unsigned), which includes verifying data structure, data integrity, and looking up its attestation on the KILT blockchain.
 * In most cases, credentials submitted by a third party would be expected to be signed (a 'presentation').
 * To verify the additional signature as well, use `verifyPresentation`.
 *
 * @param credential - The object to check.
 * @param options - Additional parameter for more verification steps.
 * @param options.ctype - CType which the included claim should be checked against.
 * @returns A [[VerifiedCredential]] object, which is the orignal credential with two additional properties: a boolean `revoked` status flag and the `attester` DID.
 */
async function verifyCredential(credential, { ctype } = {}) {
    verifyWellFormed(credential, { ctype });
    const { revoked, attester } = await verifyAttested(credential);
    return {
        ...credential,
        revoked,
        attester,
    };
}
exports.verifyCredential = verifyCredential;
/**
 * Performs all steps to verify a credential presentation (signed).
 * In addition to verifying data structure, data integrity, and looking up the attestation record on the KILT blockchain,
 * this involves verifying the claimer's signature over the credential.
 *
 * This is the function verifiers would typically call upon receiving a credential presentation from a third party.
 * The attester's identity and the credential revocation status returned by this function would then be either displayed to an end user
 * or processed in application logic deciding whether to accept or reject a credential submission
 * (e.g., by matching the attester DID against an allow-list of trusted attesters).
 *
 * @param presentation - The object to check.
 * @param options - Additional parameter for more verification steps.
 * @param options.ctype - CType which the included claim should be checked against.
 * @param options.challenge -  The expected value of the challenge. Verification will fail in case of a mismatch.
 * @param options.didResolveKey - The function used to resolve the claimer's key. Defaults to [[resolveKey]].
 * @returns A [[VerifiedCredential]] object, which is the orignal credential presentation with two additional properties:
 * a boolean `revoked` status flag and the `attester` DID.
 */
async function verifyPresentation(presentation, { ctype, challenge, didResolveKey = did_1.resolveKey } = {}) {
    await verifySignature(presentation, {
        challenge,
        didResolveKey,
    });
    return verifyCredential(presentation, { ctype });
}
exports.verifyPresentation = verifyPresentation;
/**
 * Type Guard to determine input being of type [[ICredential]].
 *
 * @param input - A potentially only partial [[ICredential]].
 *
 * @returns  Boolean whether input is of type ICredential.
 */
function isICredential(input) {
    try {
        verifyDataStructure(input);
    }
    catch (error) {
        return false;
    }
    return true;
}
exports.isICredential = isICredential;
/**
 * Type Guard to determine input being of type [[ICredentialPresentation]].
 *
 * @param input - An [[ICredential]], [[ICredentialPresentation]], or other object.
 *
 * @returns  Boolean whether input is of type ICredentialPresentation.
 */
function isPresentation(input) {
    return (isICredential(input) &&
        (0, did_1.isDidSignature)(input.claimerSignature));
}
exports.isPresentation = isPresentation;
/**
 * Gets the hash of the credential.
 *
 * @param credential - The credential to get the hash from.
 * @returns The hash of the credential.
 */
function getHash(credential) {
    return credential.rootHash;
}
exports.getHash = getHash;
/**
 * Gets names of the credentialâ€™s attributes.
 *
 * @param credential The credential.
 * @returns The set of names.
 */
function getAttributes(credential) {
    // TODO: move this to claim or contents
    return new Set(Object.keys(credential.claim.contents));
}
/**
 * Creates a public presentation which can be sent to a verifier.
 * This presentation is signed.
 *
 * @param presentationOptions The additional options to use upon presentation generation.
 * @param presentationOptions.credential The credential to create the presentation for.
 * @param presentationOptions.signCallback The callback to sign the presentation.
 * @param presentationOptions.selectedAttributes All properties of the claim which have been requested by the verifier and therefore must be publicly presented.
 * @param presentationOptions.challenge Challenge which will be part of the presentation signature.
 * If not specified, all attributes are shown. If set to an empty array, we hide all attributes inside the claim for the presentation.
 * @returns A deep copy of the Credential with all but `publicAttributes` removed.
 */
async function createPresentation({ credential, signCallback, selectedAttributes, challenge, }) {
    // filter attributes that are not in public attributes
    const excludedClaimProperties = selectedAttributes
        ? Array.from(getAttributes(credential)).filter((property) => !selectedAttributes.includes(property))
        : [];
    // remove these attributes
    const presentation = removeClaimProperties(credential, excludedClaimProperties);
    const signature = await signCallback({
        data: makeSigningData(presentation, challenge),
        did: credential.claim.owner,
        keyRelationship: 'authentication',
    });
    return {
        ...presentation,
        claimerSignature: {
            ...(0, did_1.signatureToJson)(signature),
            ...(challenge && { challenge }),
        },
    };
}
exports.createPresentation = createPresentation;
