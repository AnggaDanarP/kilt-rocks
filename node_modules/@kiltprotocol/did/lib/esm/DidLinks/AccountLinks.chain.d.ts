/**
 * Copyright (c) 2018-2023, BOTLabs GmbH.
 *
 * This source code is licensed under the BSD 4-Clause "Original" license
 * found in the LICENSE file in the root directory of this source tree.
 */
/// <reference types="bn.js" />
import type { KeypairType } from '@polkadot/util-crypto/types';
import { BN } from '@polkadot/util';
import type { DidUri, HexString, KeyringPair, KiltAddress } from '@kiltprotocol/types';
/**
 *  A chain-agnostic address, which can be encoded using any network prefix.
 */
export declare type SubstrateAddress = KeyringPair['address'];
export declare type EthereumAddress = HexString;
export declare type Address = KiltAddress | SubstrateAddress | EthereumAddress;
/**
 * Format a blockchain address to be used as a parameter for the blockchain API functions.
 *
 * @param account The account to format.
 * @returns The blockchain-formatted account.
 */
export declare function accountToChain(account: Address): Address;
declare type LinkingInfo = [Address, unknown];
declare type AssociateAccountToChainResult = [
    ({
        Polkadot: LinkingInfo;
    } | {
        Ethereum: LinkingInfo;
    }),
    BN
];
/**
 * Generates the challenge that links a DID to an account.
 * The account has to sign the challenge, while the DID will sign the extrinsic that contains the challenge and will
 * link the account to the DID.
 *
 * @param did The URI of the DID that that should be linked to an account.
 * @param validUntil Last blocknumber that this challenge is valid for.
 * @returns The encoded challenge.
 */
export declare function getLinkingChallenge(did: DidUri, validUntil: BN): Promise<Uint8Array>;
/**
 * Generates the arguments for the extrinsic that links an account to a DID.
 *
 * @param accountAddress Address of the account to be linked.
 * @param validUntil Last blocknumber that this challenge is valid for.
 * @param signature The signature for the linking challenge.
 * @param type The key type used to sign the challenge.
 * @returns The arguments for the call that links account and DID.
 */
export declare function getLinkingArguments(accountAddress: Address, validUntil: BN, signature: Uint8Array, type: KeypairType): Promise<AssociateAccountToChainResult>;
/**
 * Identifies the strategy to wrap raw bytes for signing.
 */
export declare type WrappingStrategy = 'ethereum' | 'polkadot';
/**
 * Wraps the provided challenge according to the key type.
 *
 * Ethereum addresses will cause the challenge to be prefixed with
 * `\x19Ethereum Signed Message:\n` and the length of the message.
 *
 * For all other key types the message will be wrapped in `<Bytes>..</Bytes>`.
 *
 * @param type The key type that will sign the challenge.
 * @param challenge The challenge to proof ownership of both account and DID.
 * @returns The wrapped challenge.
 */
export declare function getWrappedChallenge(type: WrappingStrategy, challenge: Uint8Array): Uint8Array;
/**
 * Builds the parameters for an extrinsic to link the `account` to the `did` where the fees and deposit are covered by some third account.
 * This extrinsic must be authorized using the same full DID.
 * Note that in addition to the signing account and DID used here, the submitting account will also be able to dissolve the link via reclaiming its deposit!
 *
 * @param accountAddress Address of the account to be linked.
 * @param did Full DID to be linked.
 * @param sign The sign callback that generates the account signature over the encoded (DidAddress, BlockNumber) tuple.
 * @param nBlocksValid The link request will be rejected if submitted later than (current block number + nBlocksValid)?
 * @returns An array of parameters for `api.tx.didLookup.associateAccount` that must be DID-authorized by the full DID used.
 */
export declare function associateAccountToChainArgs(accountAddress: Address, did: DidUri, sign: (encodedLinkingDetails: HexString) => Promise<Uint8Array>, nBlocksValid?: number): Promise<AssociateAccountToChainResult>;
export {};
